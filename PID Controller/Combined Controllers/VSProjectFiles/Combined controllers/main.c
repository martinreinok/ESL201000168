/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  xxmain.c
 *  subm:  PositionControllerTilt
 *  model: PositionControllerTilt
 *  expmt: Jiwy-1
 *  date:  June 9, 2023
 *  time:  10:02:48 AM
 *  user:  20-sim 5.0 Student License
 *  from:  Universiteit Twente
 *  build: 5.0.2.12127
 **********************************************************/

 /* This file is a demo application of how the submodel function can
  * be used. It uses the global time variables that are used by both
  * the submodel and the integration method.
  *
  * PLEASE NOTE: THIS IS AN EXAMPLE WHERE ALL INPUTS ARE ZERO !
  * USE YOUR OWN INPUTS INSTEAD!! ALSO THE SUBMODEL MIGHT SIMPLY
  * NOT WORK CORRECTLY WITH INPUTS THAT ARE ZERO.
  */

  /* 20-sim include files */
#include "../../Tiltsubmod.h"
#include "../../Pansubmod.h"


#include <stdio.h>

# define	PI	3.14159265358979323846

int convertToPwm(XXDouble pidOutput) {
	const int bitSize = 4096;
	const int bits = bitSize / 2;

	/* Calculation */
	return (int)(bits * pidOutput);
}

float convertPanToRadian(int panEncoderInput) {
	const int countsPerRev = 2000;
	const int centerPos = countsPerRev / 2;
	const float countPerDeg = (float)countsPerRev / 360;

	const float degToRadian = (float)(PI / 180);

	//printf("countPerDeg Tilt: %f \n", countPerDeg);
	//printf("degToRadian Tilt: %f \n", degToRadian);

	/* Calculation */
	return (float)(panEncoderInput - centerPos) * (degToRadian / countPerDeg);
}

float convertTiltToRadian(int tiltEncoderInput) {
	const int countsPerRev = 500;
	const int centerPos = countsPerRev / 2;
	const float countPerDeg = (float)countsPerRev / 360;

	const float degToRadian = (float) (PI / 180);

	//printf("countPerDeg Tilt: %f \n", countPerDeg);
	//printf("degToRadian Tilt: %f \n", degToRadian);

	/* Calculation */
	return (float) (tiltEncoderInput - centerPos) * (degToRadian / countPerDeg);
}

/* The main function */
int main()
{
	
	XXDouble u_Tilt[3 + 1];
	XXDouble y_Tilt[1 + 1];

	XXDouble u_Pan[2 + 1];
	XXDouble y_Pan[2 + 1];

	/* Initialize the inputs and outputs of TIlt controller with correct initial values */
	u_Tilt[0] = 0.0;		/* corr */
	u_Tilt[1] = 1.0;		/* in */
	u_Tilt[2] = 0.0;		/* position */

	y_Tilt[0] = 0.0;		/* out */

	/* Initialize the inputs and outputs of Pan Controller with correct initial values */
	u_Pan[0] = 1.0;		/* in */
	u_Pan[1] = 0.0;		/* position */

	y_Pan[0] = 0.0;		/* corr */
	y_Pan[1] = 0.0;		/* out */

	int panEncoder = 1000;
	int tiltEncoder = 250;

	/* Initialize the submodel itself */
	TiltInitializeSubmodel(u_Tilt, y_Tilt, Tilt_time);
	PanInitializeSubmodel(u_Pan, y_Pan, Pan_time);


	/* Simple loop, the time is incremented by the integration method */
	while ((Tilt_time < Tilt_finish_time) || (Pan_time < Pan_finish_time))
	{
		/* Call the submodel to calculate the output */
		if (Tilt_stop_simulation == XXFALSE)
		{
			TiltCalculateSubmodel(u_Tilt, y_Tilt, Tilt_time);
			tiltEncoder += 1;
		}
			
		if (Pan_stop_simulation == XXFALSE)
		{
			PanCalculateSubmodel(u_Pan, y_Pan, Pan_time);
			panEncoder += 4;
		}	

		u_Pan[1] = convertPanToRadian(panEncoder);		// set input controller from Pan encoder value
		u_Tilt[2] = convertTiltToRadian(tiltEncoder);	// set input controller from Tilt encoder value

		u_Tilt[0] = y_Pan[0];

		// printf("Output Tilt: %f / pwm: %d / encoder: %d / rad: %f\n", y_Tilt[0], convertToPwm(y_Tilt[0]), tiltEncoder, convertTiltToRadian(tiltEncoder));
		// printf("Output Pan: %f / pwm: %d / encoder: %d / rad: %f\n", y_Pan[1], convertToPwm(y_Pan[1]), panEncoder, convertPanToRadian(panEncoder));
		printf("Output Tilt: %f \n", y_Tilt[0]);
		printf("Output Pan: %f \n", y_Pan[1]);
	}

	/* Perform the final calculations */
	TiltTerminateSubmodel(u_Tilt, y_Tilt, Tilt_time);
	PanTerminateSubmodel(u_Pan, y_Pan, Pan_time);

	/* and we are done */
	return 0;
}

